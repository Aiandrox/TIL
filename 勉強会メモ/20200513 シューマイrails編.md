# クックパッド

MVC以上のレイヤーは増やさない。

app/services　複数modelにまたがる。

決済stripe / push通知firebase

## 物体と概念のmodel設計
冷蔵庫 has_many コンテナ　コンテナhas_many商品。

コンテナの内容が毎日変わるので、「ある日のコンテナ」という概念のモデルを作る。

→DBのリファクタリングを積極的に

## 制約の設計
配送車のキャパ、コンテナの容量

商品の重さと体積を測定

商品に対して採番処理としてServiceClassにまとめる

タイムセール→同一データへのread/write集中

## DB的なバリデーションがよくても……

受け取り場所に行かない車に商品が！！

→バッチ処理でデータのチェックを行う

## 質問

Q. DB再設計って開発コストめちゃくちゃ高いと思いますが、どうやって周囲を説得して進めてるんですか？

A. 説得は特にない。テックリードが率先していた。説明したら納得してもらえた。
流通を止められないので、回しながらリファクタリングをするのが難しかった


Q. 技術選定でrailsを選んだ理由

A. 再利用できる資産としてrailsが多かった
乗り換えも全然あり。乗り換えるならGoかなあ……速度的に


Q. 本番データの想定が難しいイメージなのですが、開発環境のデータとかTESTはどうしていますか？

A. 本願環境のデータをデプリケーションしている。個人情報だけ消して。
テストコードガッツリ書く。


Q. 運用体制

A. 毎日2人くらいで当番制で見る。エラーチャンネル見てやばいのは一時的に担当する。


Q. DB再設計時にすでに入ってるデータとかの整合性とか抜きにして再設計を考えてますか？

A. 過去データは見れなくなるとかも許容。

-----

# リンクアンドモチベーション

railsのレールにのっかっていたら鈍行だった

## バリデーション

ひとつずつバリデーションが起こる……。

→バリデーションを定義しないor別に作る。

→activerecord-importでクエリの発行数を減らす

##コールバックの数

→コールバックを使わない

## 参照編

###　activerecordのオブジェクトがでかい

全カラムを取得してしまうので。

→selctでカラムを絞る、pluckで純粋な配列にする（activerecordのオブジェクトは重い）

### よくあるn+1問題

→bullet導入

### インデックスをちゃんと貼る

→データベースの`slow.log`を見る。

EXPLAINで検証しつつ　mysqlだとlog_queriesうんたらを使うとなんかいいらしい

## まとめ

コードだけではなくDB設計を変えないといけないケースが3割（工数では5割）

設計を変えるより仕様を変えるほうが大変

## 質問

Q. bulletの検出通りにN+1 問題を解消すると、場合によっては余計処理に時間かかると思うのですがどう対応していますか？

A. あくまで参考にだけ。処理が重くなったら戻す。
データ数によっても変わるので、データ数は多いやつで検証する


Q. 会社でレスポンスタイム何ms以内にするなど目標値ってあったりしますか？

A. 画面表示は1秒以内に。一括処理や仕方ない場合は3, 5秒などに緩める


Q. DBインデックスの見直しは、運用を開始されてからも定期的に実施しているのでしょうか？メンテナンス時間帯などを決めて、インデックスの追加をしているのでしょうか？

A. 運用を開始されてからも定期的に実施している。期間を決めているわけではない。随時。

Q. 性能を測るにあたってどのように計測していますか？new relic で毎月確認とかですか？

A. データドックで一部監視。今回のプロジェクトは現在の数の倍の人数を導入するための性能改善だったので、一万人超えのデータを定義して仮想の企業を定義して、実際に動かして洗い出した。

---

# freee

RailsとJSON:APIによるマイクロサービス構築事例

課金基盤が複雑。
プロダクト、プラン、ラインナップ、継続課金と都度課金など。

技術は大体rails。切りよくマイクロサービスごとにわけたり。

価格表、契約管理、請求・決済にはZuoraを利用

## JSON:APIとは

HTTPとJSONを利用してデータ操作を行う。

## サーバー側

rails向け: ActiveModel::Serializers, Netflix/fast jsonapi

リソースのCRUD操作（GET: フィルター、ソート、リレーション、ページネーション）、操作結果の通知（HTTPステータス、エラー構造体、メタデータ）ができるよ！

やっぱり`{ data: { id: , type: , attributes: {}}}`みたいな形が一般的なのか……。→json_api規約
idとtypeが別扱いなのはリクエストURLと対応しているからなのか（独り言）
やっぱりAMSはリクエストをデシリアイズする機能ないよなーーー！？

## クライアント側

JsonApiClientをラップしたgemを配布　→制約によってRESTに忠実なAPI設計

リソースに対応するLicenseクラス（中身はURLを定義するだけ）を作る。`License.where(company_id:10).first`みたいな書き方でリクエストを送ることができる！すごい！

さらにレスポンスがActiveModelオブジェクトに変換される。すごい！！

実質ActiveRecordみたいなデータの引き出し方ができる！！！すごい！！！

※JsonApiClientはfaradayに依存するので、バージョン注意。 

-----------

# コンテナが一般化した現代のRails運用

自己紹介のself.inspectって書き方かっこいい

## インフラの歴史

太古：手順書

あたたかみのある手作業


古代：シェルスクリプト

構築済みのサーバーは直せない


中世：chef, ansible

DSLによるザーバーの自動構成。構築後の変更もコードで管理

冪等なコードを保つのが難しい。（大雑把に言って、ある操作を1回行っても複数回行っても結果が同じであることをいう概念らしい）


近代：ゴールデンイメージ


現代：コンテナ

まるごとパッケージ化できる。


## buildkitを使ったモダンなrailsアプリケーションイメージの構成方法

node.jsはmulti stageビルドで入れる。
しかわからんかったので以上。

### 設定値について

イメージには含めたくない。
外部から注入

### 基本　環境変数化
秘匿情報をどこで管理するのか。
参照権限の管理

### KMSの利用
AWSやGCPなどのクラウド環境ならIAMで管理できる。
（CircleCIにmaster.key入れたのと同じような感じかな？）

### S3にKMSで暗号化した設定ファイルを配置する
`aws s3 cp s3:myapp-configs/なんちゃら〜`アクセス権限がなければエラー

### ParameterStoreの活用
起動時にAPIを叩いて環境変数に設定するラッパーツールを書いたり。

### ログ出力とエラー管理
LoggingDriver：標準出力、標準エラー出力からログを読みとる

最終出力先：cloudwatch logsが現代的。あとは何言ってるかわからん

エラートラッキング：sentry, rollbarが流行っぽい

デプロイ：ECSを利用していたのでcapistranoのプラグインを自作しているらしい
