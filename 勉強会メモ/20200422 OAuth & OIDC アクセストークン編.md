# OAuth & OIDC アクセストークン編 by #authlete

## アクセストークンを渡す方法

1. Authorizationヘッダー  
Bearer アクセストークン  
　　　　→認可サーバーから受け取ったアクセストークンそのもの（b64tokenという名前だけどb64しない）  
1. form encoded body parameter
1. クエリに含めるパターン

他　DPop-boundアクセストークン

## アクセストークンを受け取ったときの応答
エラーの返し方
`WWW-Authenticate: Bearer error=“invalid_token”, error_description=“The access token expire”`みたいな形式で返すこと  
invalid_request, invalid_token, insufficient_scopeの三種類のerrorパラメータ（決まっている）

## アクセストークンの実装、取得方法
### 識別子型

アクセストークンに紐づく情報を認可サーバーのデータベースに保存  
認可サーバーに問い合わせければならない（元々持っていないからね）イントロスペクションAPI（標準RFC7662）を呼ぶ。  
リクエストにはtokenが必須。token_type_hintは任意（これはあってもなくてもそんなに問題はない…）

レスポンスはactiveが必須。それ以外は任意。いろいろ、、  
このエンドポイントは誰でもアクセスできるとだめ！でも、保護の方法は任せるよ。  
例はクライアント認証。それを使えとな？→それはクライアント認証に見えるだけのやつや……いちいち作るの面倒だったから使いまわしてるだけ。  
docを見るとまじでクライアント認証しか選択しなくね？

### 内包型
アクセストークンに紐づく情報をアクセストークン自体の中に含める

良: イントロスペクションAPIを呼ばなくていいので、認可サーバーとの通信が発生しない。  
悪: アクセストークンを失効させたい、署名や暗号化にどうせ通信が必要なので、アクセストークンの有効期限を短くして、失効させることを諦めないと（妥協…）メリットが得られない。

結論：通信ができない場合しかこれを使う理由がない

### ハイブリッド型
どっちも。重複するのもあるし、データベースに入れるものもある 
